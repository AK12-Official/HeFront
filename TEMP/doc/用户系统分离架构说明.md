# MallLite系统用户分离架构说明

## 系统架构概述

MallLite电商系统采用了用户系统分离的架构设计，确保后台管理系统和前台商城系统的用户数据完全独立，互不干扰。

## 用户系统分离特点

### 1. 完全独立的用户数据

#### 后台管理员 (Admin Users)
- **数据表**: `admin` 表
- **Token前缀**: `eyJhbGci...` (标准JWT)
- **权限范围**: 后台管理系统功能
- **登录入口**: `/admin/login`
- **用途**: 系统管理、商品管理、订单管理等

#### 前台商城用户 (Mall Users) 
- **数据表**: `member` 表
- **Token前缀**: `mall.` (自定义格式)
- **权限范围**: 前台商城功能
- **登录入口**: `/sso/login`
- **用途**: 购物、下单、个人中心等

### 2. Token识别机制

```typescript
// 后台管理员Token格式
"Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE2NzMzMzA0MDA5MDgsImV4cCI6MTY3MzkzNTIwMH0.signature"

// 前台商城用户Token格式  
"Bearer mall.eyJ1c2VySWQiOjEsInR5cGUiOiJtYWxsX3VzZXIiLCJzdWIiOiJjdXN0b21lcjAxIiwiY3JlYXRlZCI6MTYwMDAwMDAwMCwiZXhwIjoxNjA2MDQ4MDAwfQ.signature"
```

### 3. API接口隔离

#### 后台管理API前缀: `/admin/`
- `/admin/login` - 管理员登录
- `/admin/info` - 获取管理员信息
- `/admin/list` - 管理员列表
- `/product/*` - 商品管理
- `/order/*` - 订单管理
- `/role/*` - 角色管理

#### 前台商城API前缀: `/sso/` 和 `/member/`
- `/sso/login` - 用户登录
- `/sso/register` - 用户注册
- `/sso/info` - 获取用户信息
- `/member/list` - 用户列表（仅后台查看）

## 数据库设计

### Admin表（后台管理员）
```sql
CREATE TABLE admin (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(64) UNIQUE NOT NULL,
    password VARCHAR(64) NOT NULL,
    icon VARCHAR(500),
    email VARCHAR(100),
    nick_name VARCHAR(200),
    note VARCHAR(500),
    create_time DATETIME,
    login_time DATETIME,
    status INT(1) DEFAULT 1
);
```

### Member表（前台用户）
```sql
CREATE TABLE member (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    member_level_id BIGINT,
    username VARCHAR(64) UNIQUE,
    password VARCHAR(64),
    nickname VARCHAR(64),
    phone VARCHAR(64),
    status INT(1),
    create_time DATETIME,
    icon VARCHAR(500),
    gender INT(1),
    birthday DATE,
    city VARCHAR(64),
    job VARCHAR(100),
    personalized_signature VARCHAR(200),
    source_type INT(1),
    integration INT,
    growth INT,
    lucky_count INT,
    history_integration INT
);
```

## 安全特性

### 1. Token验证
- 后台Token包含管理员权限信息
- 前台Token包含用户类型标识 `"type": "mall_user"`
- 系统通过Token前缀区分用户类型

### 2. 权限隔离
- 后台管理员不能使用前台接口
- 前台用户不能访问后台管理功能
- 跨系统访问将返回401未授权错误

### 3. 数据隔离
- 两套用户系统使用不同的数据表
- 用户名可以重复（不同系统）
- 密码加密方式可以不同

## API接口对照表

| 功能         | 后台管理API                  | 前台商城API                | 说明                           |
| ------------ | ---------------------------- | -------------------------- | ------------------------------ |
| 用户登录     | `POST /admin/login`          | `POST /sso/login`          | 完全独立的登录接口             |
| 获取用户信息 | `GET /admin/info`            | `GET /sso/info`            | 返回不同的用户信息结构         |
| 用户注册     | `POST /admin/register`       | `POST /sso/register`       | 管理员由超管创建，用户自助注册 |
| 刷新Token    | `GET /admin/refreshToken`    | `GET /sso/refreshToken`    | 使用不同的Token格式            |
| 修改密码     | `POST /admin/updatePassword` | `POST /sso/updatePassword` | 不同的验证机制                 |
| 用户列表     | `GET /admin/list`            | `GET /member/list`         | 管理员列表 vs 会员列表         |

## Mock数据分离

### 1. 管理员数据 (admin.ts)
```typescript
const mockAdmins = [
  {
    id: 1,
    username: 'admin',
    password: '123456',
    nickName: '超级管理员',
    email: 'admin@malllite.com'
    // ... 其他管理员特有字段
  }
]
```

### 2. 商城用户数据 (user-separation.ts)
```typescript
const mockMallUsers = [
  {
    id: 1,
    username: 'customer01',
    password: '123456',
    nickname: '张三',
    phone: '13800138001',
    memberLevelId: 2
    // ... 其他用户特有字段
  }
]
```

## 前端处理建议

### 1. Token存储
```typescript
// 根据不同的系统存储不同的Token key
const ADMIN_TOKEN_KEY = 'admin_token'
const MALL_TOKEN_KEY = 'mall_token'

// 根据当前模块选择对应的Token
const getToken = (userType: 'admin' | 'mall') => {
  return localStorage.getItem(userType === 'admin' ? ADMIN_TOKEN_KEY : MALL_TOKEN_KEY)
}
```

### 2. 路由守卫
```typescript
// 管理后台路由守卫
if (route.path.startsWith('/admin')) {
  const adminToken = getToken('admin')
  if (!adminToken || adminToken.startsWith('mall.')) {
    return '/admin/login'
  }
}

// 商城路由守卫  
if (route.path.startsWith('/user')) {
  const mallToken = getToken('mall')
  if (!mallToken || !mallToken.startsWith('mall.')) {
    return '/login'
  }
}
```

### 3. 请求拦截器
```typescript
// 根据请求URL自动添加对应的Token
axios.interceptors.request.use(config => {
  if (config.url?.includes('/admin/')) {
    config.headers.Authorization = `Bearer ${getToken('admin')}`
  } else if (config.url?.includes('/sso/') || config.url?.includes('/member/')) {
    config.headers.Authorization = `Bearer ${getToken('mall')}`
  }
  return config
})
```

## 部署建议

### 1. 服务分离
- 建议将后台管理和前台商城部署为不同的服务
- 使用不同的域名或端口
- 配置独立的JWT密钥

### 2. 数据库分离
- 可以使用同一数据库的不同表
- 或者完全分离为两个数据库
- 建议配置独立的数据库用户权限

### 3. 缓存分离  
- Redis Key使用不同前缀
- 会话存储使用不同的命名空间

## 常见问题

### Q: 为什么要分离用户系统？
A: 
1. **安全性**: 避免权限混乱，防止普通用户误入管理后台
2. **扩展性**: 两套系统可以独立演进，有不同的用户属性
3. **维护性**: 代码结构更清晰，职责分离明确

### Q: 用户名可以重复吗？
A: 可以。由于是两套独立的用户系统，用户名可以在不同系统中重复。

### Q: 如何区分Token类型？
A: 通过Token的格式前缀：
- 管理员Token: 标准JWT格式
- 商城用户Token: `mall.` 前缀格式

### Q: 后台能查看商城用户信息吗？
A: 可以。后台提供了 `/member/*` 接口来查看和管理商城用户，但商城用户不能登录后台系统。

## 总结

这种用户系统分离的架构设计确保了：
1. 数据安全性和系统稳定性
2. 清晰的权限边界
3. 易于维护和扩展
4. 符合电商系统的实际业务需求

通过Mock数据的完整实现，开发团队可以在前后端分离的情况下并行开发，提高开发效率。
